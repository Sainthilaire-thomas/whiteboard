# üìã Affectation de Crit√®res aux Passages Top√©s - Whiteboard

## üéØ Vue d'ensemble

Extension du module Whiteboard permettant aux **participants** d'affecter des crit√®res qualit√© aux passages d'appels qu'ils ont pr√©alablement "top√©s" pendant l'√©coute. Cette fonctionnalit√© r√©utilise le composant `GridContainerSujetsEval` existant et s'int√®gre dans le syst√®me d'√©valuation collaborative temps r√©el.

## üîÑ Workflow utilisateur

1. **Phase d'√©coute** : Les participants √©coutent l'appel et "topent" les passages int√©ressants avec `AddPostitButton`
2. **Phase d'affectation** : Une fois l'√©coute termin√©e, retour sur les passages top√©s pour les affecter aux crit√®res qualit√©
3. **Synchronisation** : Les affectations sont visibles en temps r√©el par tous les participants et le coach

## üìä Architecture des donn√©es

### Tables principales

#### `whiteboard.participant_evaluations` (12 colonnes) ‚úÖ **EXISTANTE**

```sql
-- ‚úÖ Table d√©j√† cr√©√©e en base - 12 colonnes
-- Structure exacte √† r√©cup√©rer pour comprendre le mapping
-- Stockage des affectations crit√®res ‚Üî passages par les participants
-- Questions : participant_id, passage_reference, timestamp, idsujet ?
```

#### `activitesconseillers_sujets` (√©valuations coach) ‚úÖ **EXISTANTE**

```sql
CREATE TABLE activitesconseillers_sujets (
  idactivitesujet INTEGER PRIMARY KEY,
  idactivite INTEGER NOT NULL,           -- R√©f√©rence activitesconseillers
  idsujet INTEGER NOT NULL,              -- R√©f√©rence sujets (crit√®re qualit√©)
  travaille BOOLEAN,                     -- Crit√®re travaill√© en coaching
  note_conformite TEXT                   -- Note de conformit√© du crit√®re
);
```

#### `callactivityrelation` (relation appel ‚Üî activit√©) ‚úÖ **EXISTANTE**

```sql
CREATE TABLE callactivityrelation (
  callid INTEGER NOT NULL,              -- Lookup table call
  activityid INTEGER NOT NULL           -- Lookup table activitesconseillers
);
```

#### `sujets` (r√©f√©rentiel crit√®res qualit√©) ‚úÖ **EXISTANTE**

```sql
CREATE TABLE sujets (
  idsujet INTEGER PRIMARY KEY,
  iddomaine INTEGER NOT NULL,           -- Domaine (ex: grille Poste, ESCDA)
  nomsujet TEXT NOT NULL,               -- Nom du crit√®re (rubrique grille)
  description TEXT,                     -- Description/lexique/attendu
  valeurnum√©rique INTEGER DEFAULT 1,    -- Valeur par d√©faut (0 si non ma√Ætris√©)
  idcategoriesujet INTEGER NOT NULL     -- Cat√©gorie pour regroupement/couleur
);
```

### Tables whiteboard existantes

#### `whiteboard.postits` (passages top√©s)

```sql
-- Structure existante - 7 colonnes
-- Contient les passages "top√©s" par les participants
```

#### `whiteboard.shared_evaluation_sessions` (sessions collaboratives)

```sql
-- Structure existante - 17 colonnes
-- Gestion des sessions de partage temps r√©el
```

## üèóÔ∏è Architecture technique propos√©e

### Composant principal : `PassageCriteriaAssignment`

```typescript
interface PassageCriteriaAssignmentProps {
  toppedPassages: ToppedPassage[]; // Passages d√©j√† top√©s
  sessionId: string; // Session whiteboard active
  participantId?: string; // ID participant (non-auth)
  onAssignmentComplete: () => void; // Callback fin d'affectation
}

interface ToppedPassage {
  id: number;
  timestamp: number;
  text: string;
  wordIndex?: number;
  isAssigned: boolean; // A des crit√®res affect√©s
  assignedCriteria: number[]; // IDs des sujets affect√©s
}
```

### Workflow technique d√©taill√©

#### 1. Mode "Affectation" dans whiteboard

```typescript
// √âtat du composant
const [mode, setMode] = useState<'listening' | 'assignment'>('listening');
const [selectedPassage, setSelectedPassage] = useState<ToppedPassage | null>(null);

// Bouton pour basculer en mode affectation
<Button
  onClick={() => setMode('assignment')}
  disabled={toppedPassages.length === 0}
>
  Affecter les crit√®res aux passages top√©s ({toppedPassages.length})
</Button>
```

#### 2. Liste des passages √† affecter

```typescript
// Affichage des passages avec statut d'affectation
{toppedPassages.map(passage => (
  <PassageCard
    key={passage.id}
    passage={passage}
    isAssigned={passage.isAssigned}
    assignedCount={passage.assignedCriteria.length}
    onClick={() => openCriteriaModal(passage)}
  >
    <Chip
      label={passage.isAssigned ? `${passage.assignedCriteria.length} crit√®res` : '√Ä √©valuer'}
      color={passage.isAssigned ? 'success' : 'warning'}
    />
  </PassageCard>
))}
```

#### 3. Modal r√©utilisant GridContainerSujetsEval

```typescript
<Modal open={selectedPassage !== null} onClose={closeCriteriaModal}>
  <Box sx={{ width: '80vw', maxHeight: '80vh', overflow: 'auto' }}>
    {/* Contexte du passage */}
    <Typography variant="h6">
      Passage s√©lectionn√©
    </Typography>
    <Typography variant="body2" sx={{ fontStyle: 'italic', mb: 2 }}>
      "{selectedPassage?.text}"
    </Typography>
    <Typography variant="caption" sx={{ mb: 3, display: 'block' }}>
      Timestamp : {selectedPassage?.timestamp}s
    </Typography>

    {/* R√©utilisation exacte du composant existant */}
    <GridContainerSujetsEval
      categories={categories}
      items={sujets}
      columnConfig={columnConfig}
      handleSujetClick={handleAssignCriteria}        // ‚ö° Adaptation ici
      sujetsDeLActivite={selectedPassage?.assignedCriteria || []}
    />

    <Box sx={{ display: 'flex', justifyContent: 'space-between', mt: 2 }}>
      <Button onClick={closeCriteriaModal}>Fermer</Button>
      <Button variant="contained" onClick={saveAssignment}>
        Valider l'affectation
      </Button>
    </Box>
  </Box>
</Modal>
```

#### 4. Adaptation de handleSujetClick

```typescript
const handleAssignCriteria = async (sujet: Item) => {
  if (!selectedPassage) return;

  const isAlreadyAssigned = selectedPassage.assignedCriteria.includes(
    sujet.idsujet
  );

  // Toggle de l'affectation
  const newAssignedCriteria = isAlreadyAssigned
    ? selectedPassage.assignedCriteria.filter((id) => id !== sujet.idsujet)
    : [...selectedPassage.assignedCriteria, sujet.idsujet];

  // Sauvegarde en base de donn√©es
  await assignCriteriaToPassage({
    session_id: sessionId,
    participant_id: participantId,
    passage_data: {
      id: selectedPassage.id,
      timestamp: selectedPassage.timestamp,
      text: selectedPassage.text,
      word_index: selectedPassage.wordIndex,
    },
    idsujet: sujet.idsujet,
    action: isAlreadyAssigned ? "remove" : "assign",
  });

  // Mise √† jour locale
  setSelectedPassage({
    ...selectedPassage,
    assignedCriteria: newAssignedCriteria,
    isAssigned: newAssignedCriteria.length > 0,
  });

  // Synchronisation temps r√©el
  broadcastParticipantEvaluation(sessionId, {
    passageId: selectedPassage.id,
    assignedCriteria: newAssignedCriteria,
    participantId,
  });
};
```

## üì° APIs et synchronisation

### Nouvelle API Route : Affectation crit√®res

```typescript
// app/api/participant-evaluations/assign/route.ts
POST /api/participant-evaluations/assign

// Request body
{
  session_id: string,
  participant_id: string,
  passage_data: {
    id: number,           // ID du postit/passage top√©
    timestamp: number,    // Position temporelle dans l'appel
    text: string,         // Texte du passage
    word_index?: number   // Index du mot si applicable
  },
  idsujet: number,        // Crit√®re qualit√© √† affecter
  action: 'assign' | 'remove'  // Ajouter ou retirer le crit√®re
}

// Response
{
  success: boolean,
  assignment_id?: number,
  error?: string
}
```

### Hook de synchronisation temps r√©el

```typescript
// Hook pour synchroniser les affectations entre participants
const useRealtimeParticipantEvaluations = (sessionId: string) => {
  const [participantEvaluations, setParticipantEvaluations] = useState<
    ParticipantEvaluation[]
  >([]);

  useEffect(() => {
    // Subscription WebSocket pour les changements d'affectation
    const subscription = supabase
      .channel(`participant_evaluations_${sessionId}`)
      .on(
        "postgres_changes",
        {
          event: "*",
          schema: "whiteboard",
          table: "participant_evaluations",
          filter: `session_id=eq.${sessionId}`,
        },
        (payload) => {
          // Mise √† jour des affectations en temps r√©el
          handleEvaluationChange(payload);
        }
      )
      .subscribe();

    return () => subscription.unsubscribe();
  }, [sessionId]);

  return {
    participantEvaluations,
    broadcastParticipantEvaluation,
  };
};
```

## üé® Interface utilisateur

### Indicateurs visuels

- ‚úÖ **Passage affect√©** : Badge vert avec nombre de crit√®res
- ‚è≥ **Passage non affect√©** : Badge orange "√Ä √©valuer"
- üë• **Affectations multiples** : Indicateur nombre de participants ayant √©valu√©
- üéØ **Crit√®res populaires** : Mise en √©vidence des crit√®res les plus s√©lectionn√©s

### R√©utilisation composants existants

- **GridContainerSujetsEval** : Aucune modification n√©cessaire
- **Couleurs cat√©gories** : M√™me syst√®me que module √©valuation
- **Material-UI** : Coh√©rence totale avec l'existant
- **AddPostitButton** : Garde son r√¥le de "topage" initial

## üîÑ Int√©gration avec l'existant

### Hooks whiteboard √©tendus

```typescript
// Extension des hooks temps r√©el existants
const useWhiteboardEvaluation = (sessionId: string) => {
  // Combine les fonctionnalit√©s existantes + affectation crit√®res
  const toppedPassages = usePostits(sessionId);
  const participantEvaluations = useRealtimeParticipantEvaluations(sessionId);

  return {
    toppedPassages,
    participantEvaluations,
    assignCriteria: handleAssignCriteria,
    getPassageEvaluations: (passageId: number) =>
      participantEvaluations.filter((eval) => eval.passage_id === passageId),
  };
};
```

### S√©curit√© et permissions

- **Participants non-authentifi√©s** : M√™me pattern que Phase 3 (Service Role)
- **Session-based ID** : G√©n√©ration d'ID temporaire pour identifier les participants
- **RLS Supabase** : Politiques pour limiter l'acc√®s aux sessions actives

## üìã Donn√©es manquantes pour d√©veloppement

### Structure compl√®te participant_evaluations ‚úÖ **TABLE EXISTANTE**

```sql
-- ‚úÖ Table d√©j√† cr√©√©e avec 12 colonnes
-- BESOIN : Structure exacte des colonnes pour mapping
-- Questions prioritaires :
-- 1. Comment identifier un participant non-authentifi√© ? (participant_id, session_id ?)
-- 2. Lien avec le passage top√© (postit_id, word_index, timestamp ?)
-- 3. Stockage du crit√®re affect√© (idsujet ?)
-- 4. M√©tadonn√©es d'√©valuation (created_at, evaluation_type ?)
```

### Points d'int√©gration √† pr√©ciser

1. **Identification passages** : Lien entre `postits` et `participant_evaluations`
2. **Participant ID** : Strat√©gie pour les utilisateurs non-authentifi√©s
3. **Synchronisation** : Niveau de granularit√© temps r√©el (par crit√®re ou par passage complet)
4. **Validation coach** : Le coach peut-il modifier/valider les affectations participants ?

## üöÄ Plan de d√©veloppement

### Phase 1 : Composant de base (1-2 jours)

- [ ] Composant `PassageCriteriaAssignment`
- [ ] Modal avec `GridContainerSujetsEval` int√©gr√©
- [ ] Interface liste des passages top√©s
- [ ] Gestion √©tat local (sans synchronisation)

### Phase 2 : Persistance et API (1 jour)

- [ ] API Route `/api/participant-evaluations/assign`
- [ ] Hook de persistance en base
- [ ] Gestion des erreurs et feedback utilisateur

### Phase 3 : Synchronisation temps r√©el (1 jour)

- [ ] Hook `useRealtimeParticipantEvaluations`
- [ ] WebSocket pour affectations en temps r√©el
- [ ] Indicateurs visuels des affectations multiples

### Phase 4 : Int√©gration whiteboard (0.5 jour)

- [ ] Int√©gration dans le workflow whiteboard existant
- [ ] Tests avec les composants Phase 3 (synchronisation transcript)
- [ ] Validation UX compl√®te

## üéØ Crit√®res de succ√®s

- ‚úÖ **R√©utilisation maximale** : `GridContainerSujetsEval` utilis√© sans modification
- ‚úÖ **Coh√©rence UX** : Interface identique au module √©valuation
- ‚úÖ **Temps r√©el** : Affectations visibles imm√©diatement par tous
- ‚úÖ **Performance** : Pas de r√©gression sur la synchronisation existante
- ‚úÖ **S√©curit√©** : Participants non-auth avec acc√®s contr√¥l√©

## üìù Notes pour la prochaine session

### Code √† r√©cup√©rer

1. **Structure exacte** `whiteboard.participant_evaluations` ‚úÖ **TABLE EXISTANTE** (12 colonnes)
2. **Composant PostitCard/PassageCard** existant pour l'interface
3. **Hook usePostits** pour comprendre le syst√®me de topage actuel
4. **Types TypeScript** pour les passages et √©valuations

### Questions √† clarifier

1. **Workflow exact** : Quand basculer en mode affectation ?
2. **Granularit√©** : Un crit√®re par mot, phrase ou segment ?
3. **Permissions** : Qui peut affecter quoi ?
4. **Analytics** : Agr√©gation des √©valuations participants pour le coach ?

---

**Derni√®re mise √† jour** : 12/06/2025
**Status** : Sp√©cifications compl√®tes - Pr√™t pour d√©veloppement
**Prochaine √©tape** : R√©cup√©ration structures BDD + d√©veloppement Phase 1
